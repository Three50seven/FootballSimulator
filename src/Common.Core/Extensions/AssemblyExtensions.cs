using Common.Core.Domain;
using Common.Core.Validation;
using System.Reflection;

namespace Common.Core
{
    public static class AssemblyExtensions
    {
        //
        // Summary:
        //     Get all interface + class type matches in an assembly. Returns match set for
        //     exportable, non-abstract class implementations that have one top level interface.
        //
        //
        // Parameters:
        //   assembly:
        //
        //   includeAbstractBaseInterface:
        //     Include interfaces on first-level abstract base class if present. Defaults to
        //     true.
        //
        //   query:
        //     Optional filtering query to distinguish types found in the Assembly assembly.
        public static IEnumerable<TypeRegistrationMatch> GetTypeMatches(this Assembly assembly, bool includeAbstractBaseInterface = true, Func<Type, bool>? query = null)
        {
            Guard.IsNotNull(assembly, "assembly");
            var source = from type in assembly.GetExportedTypes()
                         where type.IsClass && !type.IsAbstract
                         select new
                         {
                             Type = type,
                             Interfaces = type.GetTopLevelInterfaces(includeAbstractBaseInterface)
                         };
            source = source.Where(r => r.Interfaces.Count() == 1);
            if (query != null)
            {
                source = source.Where(r => query(r.Type));
            }

            return source.Select(r => new TypeRegistrationMatch(r.Interfaces.Single(), r.Type));
        }

        //
        // Summary:
        //     Get all interface + class type matches in an assembly that implement a generic
        //     type definition genericTypeInterface.
        //
        // Parameters:
        //   assembly:
        //
        //   genericTypeInterface:
        //     Generic type definition.
        public static IEnumerable<TypeRegistrationMatch> GetGenericTypeMatches(this Assembly assembly, Type genericTypeInterface)
        {
            Guard.IsNotNull(assembly, "assembly");
            Guard.IsNotNull(genericTypeInterface, "genericTypeInterface");
            return from type in assembly.GetExportedTypes()
                   let typeInterface = (from i in type.GetInterfaces()
                                        where i.IsGenericType && i.GetGenericTypeDefinition() == genericTypeInterface
                                        select i).FirstOrDefault()
                   where !type.IsAbstract && typeInterface != null
                   select new TypeRegistrationMatch(typeInterface, type);
        }

        public static Type? GetInheritingTypeFirstOrDefault(this Assembly assembly, Type baseType)
        {
            Guard.IsNotNull(assembly, "assembly");
            Guard.IsNotNull(baseType, "baseType");
            return (from t in assembly.GetExportedTypes()
                    where !t.IsAbstract && t.IsSubclassOf(baseType)
                    select t).FirstOrDefault();
        }

        public static Type GetRequiredInheritingType(this Assembly assembly, Type interfaceType, Type baseType)
        {
            Guard.IsNotNull(assembly, "assembly");
            Guard.IsNotNull(interfaceType, "interfaceType");
            Guard.IsNotNull(baseType, "baseType");
            Type? inheritingTypeFirstOrDefault = assembly.GetInheritingTypeFirstOrDefault(baseType) ?? 
                throw new InvalidOperationException($"No implementation found for {interfaceType.FullName}. \r\nCreate implementation that inherits from {baseType.FullName} in assembly {assembly.FullName}.");
            return inheritingTypeFirstOrDefault;
        }

        //
        // Summary:
        //     Filter list of assemblies, assumed to be generated by System.AppDomain.GetAssemblies,
        //     to a custom list of assemblies. These custom assemblies are filterd by query
        //     and typically should just include the executing application assemblies. Assemblies
        //     starting with System, Microsoft, and netstandard are automatically omitted.
        //
        // Parameters:
        //   assemblies:
        //     List of active assemblies.
        //
        //   query:
        //     Required query to distinguish the list of assemblies.
        public static IEnumerable<Assembly> FilterCustomAssemblies(this IEnumerable<Assembly> assemblies, Func<Assembly, bool> query)
        {
            Guard.IsNotNull(query, nameof(query));
            return from a in assemblies.Where(query)
                   where !string.IsNullOrEmpty(a.FullName)
                   let fullName = a.FullName!
                   where !fullName.StartsWith("System.")
                   where !fullName.StartsWith("Microsoft.")
                   where !fullName.StartsWith("netstandard")
                   select a;
        }

        //
        // Summary:
        //     Get all types in assembly that have Attribute T attached.
        //
        // Parameters:
        //   assembly:
        //     Valid assembly.
        //
        //   exportableOnly:
        //     Whether to include just the exportable types in the assembly or all class types.
        //
        //
        // Type parameters:
        //   T:
        //     Specified attribute type.
        public static IEnumerable<Type> GetTypesWithAttribute<T>(this Assembly assembly, bool exportableOnly = false) where T : Attribute
        {
            Guard.IsNotNull(assembly, nameof(assembly));
            return (exportableOnly ? assembly.GetExportedTypes() : assembly.GetTypes()).Where((Type t) => t.IsClass && t.GetCustomAttribute<T>() != null);
        }
    }
}
