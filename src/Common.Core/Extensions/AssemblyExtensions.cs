using Common.Core.Domain;
using Common.Core.Validation;
using System.Reflection;

namespace Common.Core
{
    public static class AssemblyExtensions
    {
        /// <summary>
        /// Get all interface + class type matches in an assembly.
        /// Returns match set for exportable, non-abstract class implementations that have one top level interface.
        /// </summary>
        /// <param name="assembly"></param>
        /// <param name="includeAbstractBaseInterface">Include interfaces on first-level abstract base class if present. Defaults to true.</param>
        /// <param name="query">Optional filtering query to distinguish types found in the Assembly <paramref name="assembly"/>.</param>
        /// <returns></returns>
        public static IEnumerable<TypeRegistrationMatch> GetTypeMatches(
            this Assembly assembly, 
            bool includeAbstractBaseInterface = true, 
            Func<Type, bool> query = null)
        {
            Guard.IsNotNull(assembly, nameof(assembly));

            // exportable types with associated interfaces
            var registrations =
                from type in assembly.GetExportedTypes()
                where type.IsClass && !type.IsAbstract
                select new
                {
                    Type = type,
                    Interfaces = type.GetTopLevelInterfaces(includeAbstractBaseInterface)
                };

            // only registrations that have a single top level interface
            registrations = registrations.Where(r => r.Interfaces.Count() == 1);

            if (query != null)
                registrations = registrations.Where(r => query.Invoke(r.Type));

            return registrations.Select(r => new TypeRegistrationMatch(r.Interfaces.Single(), r.Type));
        }

        /// <summary>
        /// Get all interface + class type matches in an assembly that implement a generic type definition <paramref name="genericTypeInterface"/>.
        /// </summary>
        /// <param name="assembly"></param>
        /// <param name="genericTypeInterface">Generic type definition.</param>
        /// <returns></returns>
        public static IEnumerable<TypeRegistrationMatch> GetGenericTypeMatches(this Assembly assembly, Type genericTypeInterface)
        {
            Guard.IsNotNull(assembly, nameof(assembly));
            Guard.IsNotNull(genericTypeInterface, nameof(genericTypeInterface));

            return (from type in assembly.GetExportedTypes()
                    let typeInterface = (from i in type.GetInterfaces()
                                               where i.IsGenericType
                                                  && i.GetGenericTypeDefinition() == genericTypeInterface
                                               select i).FirstOrDefault()
                    where !type.IsAbstract
                        && typeInterface != null
                    select new TypeRegistrationMatch(typeInterface, type));
        }

        public static Type GetInheritingTypeFirstOrDefault(this Assembly assembly, Type baseType)
        {
            Guard.IsNotNull(assembly, nameof(assembly));
            Guard.IsNotNull(baseType, nameof(baseType));

            return assembly.GetExportedTypes().Where(t => !t.IsAbstract && t.IsSubclassOf(baseType)).FirstOrDefault();
        }

        public static Type GetRequiredInheritingType(this Assembly assembly, Type interfaceType, Type baseType)
        {
            Guard.IsNotNull(assembly, nameof(assembly));
            Guard.IsNotNull(interfaceType, nameof(interfaceType));
            Guard.IsNotNull(baseType, nameof(baseType));

            var inheritingType = GetInheritingTypeFirstOrDefault(assembly, baseType);
            if (inheritingType == null)
                throw new InvalidOperationException($@"No implementation found for {interfaceType.FullName}. 
Create implementation that inherits from {baseType.FullName} in assembly {assembly.FullName}.");

            return inheritingType;
        }

        /// <summary>
        /// Filter list of assemblies, assumed to be generated by <see cref="AppDomain.GetAssemblies"/>,
        /// to a custom list of assemblies. These custom assemblies are filterd by <paramref name="query"/>
        /// and typically should just include the executing application assemblies.
        /// Assemblies starting with System, Microsoft, and netstandard are automatically omitted.
        /// </summary>
        /// <param name="assemblies">List of active assemblies.</param>
        /// <param name="query">Required query to distinguish the list of assemblies.</param>
        /// <returns></returns>
        public static IEnumerable<Assembly> FilterCustomAssemblies(this IEnumerable<Assembly> assemblies, Func<Assembly, bool> query)
        {
            Guard.IsNotNull(query, nameof(query));

            return assemblies.Where(query)
                             .Where(a => !a.FullName.StartsWith("System."))
                             .Where(a => !a.FullName.StartsWith("Microsoft."))
                             .Where(a => !a.FullName.StartsWith("netstandard"));
        }

        /// <summary>
        /// Get all types in <paramref name="assembly"/> that have Attribute <typeparamref name="T"/> attached.
        /// </summary>
        /// <typeparam name="T">Specified attribute type.</typeparam>
        /// <param name="assembly">Valid assembly.</param>
        /// <param name="exportableOnly">Whether to include just the exportable types in the assembly or all class types.</param>
        /// <returns></returns>
        public static IEnumerable<Type> GetTypesWithAttribute<T>(this Assembly assembly, bool exportableOnly = false) where T : Attribute
        {
            Guard.IsNotNull(assembly, nameof(assembly));

            return (exportableOnly ? assembly.GetExportedTypes() : assembly.GetTypes())
                           .Where(t => t.IsClass && t.GetCustomAttribute<T>() != null);
        }
    }
}
